% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protegido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

\section{Implementación}

Una vez terminadas las dos fases previas --- análisis y diseño --- es hora de enfrentarnos a la codificación e implementación
en sí de la aplicación. Este apartado es largo y entretenido, y va descubriendo a cada momento nuevas problemáticas que
no se han tenido en cuenta antes y es necesario resolver, pero también es apasionante, porque vamos viendo de forma
empírica cómo nuestra aplicación va tomando forma y se va haciendo tangible a cada momento que avanza. \\

El desarrollo de Dominous ha presentado muchas características interesantes, problemas, dificultades y otras circunstancias
que creemos interesante destacar, y que se pasamos a comentar a continuación.

\subsection{Entorno gráfico}

El entorno gráfico se puede dividir en dos apartados de diferente complejidad: por un lado tenemos la gestión de menús,
opciones, pantallas y secciones de la aplicación, y por otro lado tenemos la gestión de una partida de dominó, con todas
sus interacciones, animaciones y movimientos de fichas, eventos y demás.

\subsubsection{Sistema de secciones}

Todo el sistema de secciones lo gobierna el objeto principal de la aplicación, llamado \textbf{dominous}. Este objeto posee
diferentes objetos como atributos, y estos atributos son las diferentes secciones de la aplicación. Cuando queremos
que el flujo de la aplicación pase de una sección a otra no tenemos más que llamarla; al llamarla estaremos ejecutando
el siguiente fragmento:

\begin{lstlisting} [language=Python, numbers=left]
def goto_tutorial(self):
    self.flow.stop()
    self.flow = self.tutorial
    self.flow.start()
\end{lstlisting}

Gracias a este tipo de llamadas podemos subdividir cómodamente la aplicación en módulos muy acotados, a los cuales se aplica
primero una función de inicialización --- por si es necesario que actualicen estructuras, datos o cualquier otra labor
de preparación que puedan requerir --- y una vez se termina también se ejecuta una función de finalización. \\

Y mientras el flujo esté asociado a una sección, todas las funciones de eventos, dibujado y actualización de la pantalla
se disparan dentro de la sección correspondiente. \\

Gracias a esta metodología hemos podido acotar de forma muy cómoda las diferentes secciones (cada una con sus peculiaridades)
y gestionar de forma independiente cada apartado, evitando posibles problemas colaterales, asegurando una buena
integración y minimizando el hecho de que errores de un apartado puedan afectar a otros. \\


\subsubsection{Gestión de partida}

Lorem ipsum


\subsection{Interfaz de sonido}

La interfaz de sonido se ha diseñado de tal forma que se gestione de forma independiente para que su uso sea sencillo,
realizando llamadas al objeto \textbf{sound} con los métodos que estimemos oportunos en cada momento, y el propio
sistema se encarga de realizar diferentes cálculos y comprobaciones:

\begin{itemize} 
    \item Por ejemplo, a la hora de ejecutar un determinado fragmento musical, controla si ya se está escuchando música
        en ese momento; si es ese el caso realiza un pequeño fundido de la pista actual, e inicia la ejecución de la
        nueva, evitando así los desagradables clicks que se podrían escuchar cuando se para y se inicia la canción.
    \item O también, para ejecutar un sonido de ficha de dominó sobre el tablero, el sistema realiza la precarga de todos
        los sonidos --- similares pero no iguales --- y dispara uno aleatoriamente, evitando que cada apartado tenga
        que gestionarlo de forma autónoma
\end{itemize}


\subsection{Configuración de la aplicación}

La configuración de la aplicación (y almacenaje de la misma) se realiza mediante ficheros de tipo \textbf{INI}. Un archivo
INI consiste en un simple archivo de texto ASCII que contiene dos tipos de entradas:

\begin{description}
    \item[Secciones] permiten agrupar parámetros relacionados. Por ejemplo: "Parámetros de red".
    \item[Valores] definen parámetros y su valor. Primero se define el nombre del parámetro y después su valor separado por
            el signo de igualdad (=).
    \item[Comentarios] permiten explicar el propósito de una sección o parámetro. Los comentarios comienzan con el carácter
            punto y coma (;).
\end{description}

El significado de secciones y valores no está bien definido y cada aplicación puede reaccionar de manera diferente ante:

\begin{itemize}
    \item Secciones duplicadas.
    \item Parámetros duplicados.
    \item El carácter de barra invertida (\textbackslash). A veces se usa para romper una línea en dos.
    \item Valores. Los valores pueden consistir en texto, números, listas separadas por comas, etc. Esto depende de la aplicación.
\end{itemize}

Las ventajas de este tipo de ficheros es su estandarización y comodidad a la hora de leer y guardar valores en fichero,
de tal forma que podemos guardar información por defecto sobre el juego de la siguiente forma:

\begin{lstlisting} [language=Python, numbers=left]
config.add_section('General')
config.set('General', 'name', 'Dominous')
config.set('General', 'window_caption', 'Dominous, an open source dominoes simulator')
config.set('General', 'lang', 'en')
config.set('General', 'points_per_game', '200')
config.add_section('Screen')
config.set('Screen', 'window_width', '800')
config.set('Screen', 'window_height', '600')
config.set('Screen', 'full_screen', 'False')
config.set('Screen', 'window_favicon', os.path.join('images', 'favicon.png'))
config.add_section('Theme')
config.set('Theme', 'theme', 'spanish')
config.add_section('Game')
config.set('Game', 'player2', 'easy')
config.set('Game', 'player3', 'easy')
config.set('Game', 'player4', 'easy')
# write our configuration file to file
with open(file, 'wb') as configfile:
    config.write(configfile)
\end{lstlisting}

Y más tarde leerlo simplemente con:

\begin{lstlisting} [language=Python, numbers=left]
config = ConfigParser.RawConfigParser()
config.read(file)
config_default = {
    'name': config.get('General', 'name'),
    'window_caption': config.get('General', 'window_caption'),
    'window_width': config.getint('Screen', 'window_width'),
    'window_height': config.getint('Screen', 'window_height'),
    'full_screen': config.get('Screen', 'full_screen'),
    'window_favicon': config.get('Screen', 'window_favicon'),
    'tile_width': 525,
    'tile_height': 270,
    'scale': 0.2,
    'theme': config.get('Theme', 'theme'),
    'lang': config.get('General', 'lang'),
    'points_per_game': config.get('General', 'points_per_game'),
    'gametype': 'human',
    'gametype_current': 'single',
    'player1': 'easy',
    'player2': 'easy',
    'player3': 'easy',
    'player4': 'easy',
    'speed': '1',
}
\end{lstlisting}

Todo ello encapsulado dentro del módulo \textbf{config.py} de la aplicación.


\subsection{Inteligencia Artificial}

Dolor sit amet
