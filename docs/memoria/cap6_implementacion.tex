% -*-cap2.tex-*-
% Este fichero es parte de la plantilla LaTeX para
% la realización de Proyectos Final de Carrera, protegido
% bajo los términos de la licencia GFDL.
% Para más información, la licencia completa viene incluida en el
% fichero fdl-1.3.tex

% Copyright (C) 2009 Pablo Recio Quijano 

\section{Implementación}

Una vez terminadas las dos fases previas --- análisis y diseño --- es hora de enfrentarnos a la codificación e implementación
en sí de la aplicación. Este apartado es largo y entretenido, y va descubriendo a cada momento nuevas problemáticas que
no se han tenido en cuenta antes y es necesario resolver, pero también es apasionante, porque vamos viendo de forma
empírica cómo nuestra aplicación va tomando forma y se va haciendo tangible a cada momento que avanza. \\

El desarrollo de Dominous ha presentado muchas características interesantes, problemas, dificultades y otras circunstancias
que creemos interesante destacar, y que se pasamos a comentar a continuación.

\subsection{Entorno gráfico}

El entorno gráfico se puede dividir en dos apartados de diferente complejidad: por un lado tenemos la gestión de menús,
opciones, pantallas y secciones de la aplicación, y por otro lado tenemos la gestión de una partida de dominó, con todas
sus interacciones, animaciones y movimientos de fichas, eventos y demás.

\subsubsection{Sistema de secciones}

Todo el sistema de secciones lo gobierna el objeto principal de la aplicación, llamado \textbf{dominous}. Este objeto posee
diferentes objetos como atributos, y estos atributos son las diferentes secciones de la aplicación. Cuando queremos
que el flujo de la aplicación pase de una sección a otra no tenemos más que llamarla; al llamarla estaremos ejecutando
el siguiente fragmento:

\begin{lstlisting} [language=Python, numbers=left]
def goto_tutorial(self):
    self.flow.stop()
    self.flow = self.tutorial
    self.flow.start()
\end{lstlisting}

Gracias a este tipo de llamadas podemos subdividir cómodamente la aplicación en módulos muy acotados, a los cuales se aplica
primero una función de inicialización --- por si es necesario que actualicen estructuras, datos o cualquier otra labor
de preparación que puedan requerir --- y una vez se termina también se ejecuta una función de finalización. \\

Y mientras el flujo esté asociado a una sección, todas las funciones de eventos, dibujado y actualización de la pantalla
se disparan dentro de la sección correspondiente. \\

Gracias a esta metodología hemos podido acotar de forma muy cómoda las diferentes secciones (cada una con sus peculiaridades)
y gestionar de forma independiente cada apartado, evitando posibles problemas colaterales, asegurando una buena
integración y minimizando el hecho de que errores de un apartado puedan afectar a otros. \\


\subsubsection{Gestión de partida}

Lorem ipsum


\subsection{Interfaz de sonido}

La interfaz de sonido se ha diseñado de tal forma que se gestione de forma independiente para que su uso sea sencillo,
realizando llamadas al objeto \textbf{sound} con los métodos que estimemos oportunos en cada momento, y el propio
sistema se encarga de realizar diferentes cálculos y comprobaciones:

\begin{itemize} 
    \item Por ejemplo, a la hora de ejecutar un determinado fragmento musical, controla si ya se está escuchando música
        en ese momento; si es ese el caso realiza un pequeño fundido de la pista actual, e inicia la ejecución de la
        nueva, evitando así los desagradables clicks que se podrían escuchar cuando se para y se inicia la canción.
    \item O también, para ejecutar un sonido de ficha de dominó sobre el tablero, el sistema realiza la precarga de todos
        los sonidos --- similares pero no iguales --- y dispara uno aleatoriamente, evitando que cada apartado tenga
        que gestionarlo de forma autónoma
\end{itemize}


\subsection{Configuración de la aplicación}

La configuración de la aplicación (y almacenaje de la misma) se realiza mediante ficheros de tipo \textbf{INI}. Un archivo
INI consiste en un simple archivo de texto ASCII que contiene dos tipos de entradas:

\begin{description}
    \item[Secciones] permiten agrupar parámetros relacionados. Por ejemplo: "Parámetros de red".
    \item[Valores] definen parámetros y su valor. Primero se define el nombre del parámetro y después su valor separado por
            el signo de igualdad (=).
    \item[Comentarios] permiten explicar el propósito de una sección o parámetro. Los comentarios comienzan con el carácter
            punto y coma (;).
\end{description}

El significado de secciones y valores no está bien definido y cada aplicación puede reaccionar de manera diferente ante:

\begin{itemize}
    \item Secciones duplicadas.
    \item Parámetros duplicados.
    \item El carácter de barra invertida (\textbackslash). A veces se usa para romper una línea en dos.
    \item Valores. Los valores pueden consistir en texto, números, listas separadas por comas, etc. Esto depende de la aplicación.
\end{itemize}

Las ventajas de este tipo de ficheros es su estandarización y comodidad a la hora de leer y guardar valores en fichero,
de tal forma que podemos guardar información por defecto sobre el juego de la siguiente forma:

\begin{lstlisting} [language=Python, numbers=left]
config.add_section('General')
config.set('General', 'name', 'Dominous')
config.set('General', 'window_caption', 'Dominous')
config.set('General', 'lang', 'en')
config.set('General', 'points_per_game', '200')
config.add_section('Screen')
config.set('Screen', 'window_width', '800')
config.set('Screen', 'window_height', '600')
config.set('Screen', 'full_screen', 'False')
config.set('Screen', 'window_favicon', os.path.join('images', 'favicon.png'))
config.add_section('Theme')
config.set('Theme', 'theme', 'spanish')
config.add_section('Game')
config.set('Game', 'player2', 'easy')
config.set('Game', 'player3', 'easy')
config.set('Game', 'player4', 'easy')
# write our configuration file to file
with open(file, 'wb') as configfile:
    config.write(configfile)
\end{lstlisting}

Y más tarde leerlo simplemente con:

\begin{lstlisting} [language=Python, numbers=left]
config = ConfigParser.RawConfigParser()
config.read(file)
config_default = {
    'name': config.get('General', 'name'),
    'window_caption': config.get('General', 'window_caption'),
    'window_width': config.getint('Screen', 'window_width'),
    'window_height': config.getint('Screen', 'window_height'),
    'full_screen': config.get('Screen', 'full_screen'),
    'window_favicon': config.get('Screen', 'window_favicon'),
    'tile_width': 525,
    'tile_height': 270,
    'scale': 0.2,
    'theme': config.get('Theme', 'theme'),
    'lang': config.get('General', 'lang'),
    'points_per_game': config.get('General', 'points_per_game'),
    'gametype': 'human',
    'gametype_current': 'single',
    'player1': 'easy',
    'player2': 'easy',
    'player3': 'easy',
    'player4': 'easy',
    'speed': '1',
}
\end{lstlisting}

Todo ello encapsulado dentro del módulo \textbf{config.py} de la aplicación.

Con esto conseguimos un sistema para almacenar la configuración del sistema mediante un método portable, cómodo, sencillo y 
editable por el usuario mediante cualquier tipo de editor de texto (en caso de que existiera cualquier tipo de problema).

\subsection{Inteligencia Artificial}

En Dominous, el Sistema Experto de Inteligencia Artificial se reparte entre varios módulos, simplificando la implementación
de las diferentes partes. Según la estructura clásica en las que se divide un Sistema Experto, podemos ver que cada
apartado genera información o conocimiento para la Inteligencia Artificial:

\begin{description}
    \item[Base de conocimientos] Contiene conocimiento modelado extraído del diálogo con un experto --- Esta base de
        conocimiento se almacena, por un lado en la biblioteca de funciones y herramientas para desempeñar una partida,
        y físicamente se almacena en el módulo de IA
    \item[Base de hechos (Memoria de trabajo)] contiene los hechos sobre un problema que se ha descubierto durante el análisis
        --- Los hechos se van creando y almacenando gracias al módulo de \textbf{Gestión de Partida de Dominó}, que
        gobierna la partida y guarda toda la información, movimientos, pasos y tiempos al colocar las fichas.
    \item[Motor de Inferencia] Modela el proceso de razonamiento humano --- gracias a la biblioteca de funciones podemos
        crear un motor de inferencia fácilmente, utilizando pequeñas reglas y dotando de peso o importancia a cada una,
        modelando exactamente el proceso de razonamiento que queramos, e incluso ofertando la posibilidad de crear
        cuantos queramos, de una forma fácil y rápida.
    \item[Módulos de justificación] Explica el razonamiento utilizado por el sistema para llegar a una determinada conclusión
        --- ya que en el dominó no se puede evaluar por sí mismo la efectividad o conveniencia de un movimiento, esta
        justificación llega del conocimiento del experto en valorar con mayor o menor peso una regla.
    \item[Interfaz de usuario] es la interacción entre el Sistema Experto y el usuario, y se realiza mediante el lenguaje
        natural --- y, en el caso de Dominous, la interfaz se comunica con el usuario mediante el módulo del motor
        gráfico del juego, que muestra fichas, movimientos y jugadores.
\end{description}

Pasemos a describir cada apartado para conocer a fondo la implementación del sistema experto.

\subsubsection{Base de conocimientos}

La base de conocimiento se obtiene desde el módulo \textbf{Gestión de Partida de Dominó}, que almacena la información
de forma global, esto es, relativa a toda la partida:

\begin{lstlisting} [language=Python, numbers=left]
self.info = {
    "date" : date,
    "place" : place,
    "max_points" : max_points,
    "player1" : player1,
    "player2" : player2,
    "player3" : player3,
    "player4" : player4,
    "team1" : player1 + " " + player3,
    "team2" : player2 + " " + player4,
    "description" : description,
    "winner_team" : "",
    "team1_points" : 0,
    "team2_points" : 0,
}
\end{lstlisting}

El identificador de cada campo es bastante descriptivo

Y también se almacena información de la mano actual y de cada movimiento de la siguiente forma:

\begin{lstlisting} [language=Python, numbers=left]
movement = {
    'player' : player,
    'tile' : tile,
    'side' : side,
    'left' : left,
    'right' : right,
    'mtime' : mtime,
}
\end{lstlisting}

Entre los campos almacenados vemos uno que nos resultará de mucho interés en posteriores usos de esta información, y es
el campo \textbf{mtime}. Este campo almacena el tiempo que ha estado el jugador pensando antes de colocar una ficha,
y gracias a que el dominó es un juego de caballeros podemos utilizar esta información para elaborar una estrategia
para conseguir la victoria. \\

Los posibles valores que puede presentar este campo son:

\begin{description}
    \item[0] El usuario no ha requerido tiempo para decidir qué ficha colocaba.
    \item[1] El usuario ha pensado entre diferentes opciones, y ha necesitado de cierto tiempo para decidir la ficha.
    \item[2] El usuario ha utilizado una cantidad de tiempo considerable para decidir la ficha a colocar.
\end{description}

\subsubsection{Base de Hechos}

La Base de Hechos se ha modularizado en pequeñas funciones o reglas, de tal forma que pueden ser fácilmente reutilizadas en
el Sistema Experto de cualquier jugador de Dominous. La estructura básica de una regla es la siguiente:

\begin{lstlisting} [language=Python, numbers=left]
class nombre_de_la_regla:
    def __init__(self):
        # inicializamos los atributos que sean necesarios
        pass
    def go(self, left_tile, right_tile, board, tiles, log):
        return ficha, lado, tiempo_pensando
\end{lstlisting}

Como vemos la estructura es sencilla, implementada mediante clases Python, y tiene una inicialización para definir los
atributos que sean necesarios, y por otra parte un método que, para una situación concreta de estado de la partida
(tablero, fichas propias, posición del jugador y toda la información generada por la partida). \\

Veamos un ejemplo práctico. Vamos a definir una regla que intente colocar sobre el tablero una ficha doble, cualquiera
que tengamos. Esta regla se implementaría de la siguiente forma:

\begin{lstlisting} [language=Python, numbers=left]
class put_any_double:
    def __init__(self):
        pass
    def go(self, left_tile, right_tile, board, tiles, log):
        for item in tiles:
            if item[0] == item[1]:
                if item[0] == left_tile or item[1] == left_tile:
                    tiles.remove(item)
                    return item, "left", 1
                    break
                elif item[0] == right_tile or item[1] == right_tile or left_tile == None:
                    tiles.remove(item)
                    return item, "right", 1
                    break
        return None, "pass", 0
\end{lstlisting}

En la inicialización no requerimos dar de alta ningún atributo, y el método \textbf{go} simplemente comprueba que, para
alguna de nuestras fichas dobles, algún lado de la mesa tenga ese mismo valor. Si lo tiene hemos conseguido realizar
esta regla, devolvemos el valor y listo. Y si no, devolvemos una señal de que no hemos tenido éxito y salimos. \\

Gracias a este sistema, simplificamos mucho el desarrollo de nuevos Sistemas Expertos, ya que:
\begin{itemize}
    \item Es muy sencillo crear nuevas reglas. Como ya vimos en El Libro del dominó de Benito Ruipérez \cite{mora90},
        muchas reglas, funciones o herramientas se basan en frases o hechos que, si se cumplen, \emph{interesa}
        \footnote{Como vemos, debemos ser cuidadosos al emplear verbos como \emph{interesa} o \emph{debemos} al hablar
        de colocar fichas. El juego del Dominó es lo suficientemente complejo y goza de muchas estrategias como para poder
        simplificarlo o decir objetivamente que debemos realizar una acción.} cumplirlos.
        Por poner un caso simple, al comenzar la partida \emph{interesa} comenzar con un doble --- o, mejor dicho, hay
        estrategias interesadas en comenzar con un doble. Para emplear este razonamiento en estas estrategias simplemente
        tenemos que añadir esta regla con el peso suficiente, y ya lo tendremos implementado.
    \item Es fácil crear nuevos sistemas, creando pilas de reglas con pesos que se van disparando si pueden cumplirse.
        Así se van creando diferentes jugadores y dotamos al juego de más variedad y diversión.
\end{itemize}

\subsubsection{Motor de Inferencia}

Dolor site
